---
title: 07. 오류 처리
date: "2022. 1. 2"
summary: Clean Code(클린 코드) 7장을 읽고 학습한 내용 정리
---

> 잘못된 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.

<br>

## 오류 코드보다 예외를 사용하라
예외 처리를 오류 코드로 하는 것은 좋지 못한다. (아주 옛날 코딩 방식 중 하나였던 것 같다.)   

예외 처리 코드는 예외를 throws해서 철저히 논리 코드와 분리하여 처리하도록 한다.    

<br>

## Try-Catch-Finally 문부터 작성하라
> try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다.

TDD에서 단위 테스트 코드를 먼저 작성하는 것과 유사하다고 생각하면 된다.    

<br>

## 미확인(unchecked) 예외를 사용하라
예외는 미확인 예외를 사용하는 것이 좋다. 확인 예외의 경우 특정 예외에 대한 처리를 하위 단계에(호출부) 강제한다. 이 경우 예외가 변경되거나 추가되면 호출하는 모든 메소드를 수정해야 하기 때문에 좋은 코드가 아니다.

<br>

## 예외에 의미를 제공하라
> 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기 쉬워진다.

자바의 경우 기본적으로 모든 예외에 대한 호출 스택을 제공한다. 하지만 호출 스택만 보고 충분한 정보를 얻을 수 없다. 오류 메시지에 실패한 연산 이름, 실패 유형 등의 충분한 정보를 담아서 넘겨준다.

<br>

## 호출자를 고려해 예외 클래스를 정의하라
> 애플리케이션에서 오류를 정의할 때 프로그래머에게 **가장 중요한 관심사는 오류를 잡아내는 방법**이 되어야 한다.

데코레이터 패턴을 사용해서 예외처리를 한다면 논리와 오류가 잘 분리되기 때문에 의존성이 크게 줄고, 테스트 코드를 작성하기도 쉬워진다.   

<br>

## 정상 흐름을 정의하라
예외라고 무조건 데코레이터 패턴으로 비즈니스 논리에서 분리해서 오류 처리를 하는 게 좋은 건 아니다.    
예외처리를 분리해서 처리하게 되면 오류 감지가 프로그램 언저리로 밀려난다는 단점이 있기 때문이다.    

일부 예외의 경우 비즈니스 로직과 멀어지면 안되는 경우가 있다. 예외처리와 비즈니스로직이 밀접한 관련이 있는 경우이다. 

개선 전
~~~java
try { 
	MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); 
	m_total += expenses.getTotal(); 
} catch (MealExpensesNotFound e) { 
	m_total += getMealPerDiem(); 
}
~~~

개선 후 (특수 사례 패턴, 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식)
~~~Java
MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); 
m_total += expenses.getTotal(); 

-----

public class PerDiemMealExpenses implements MealExpenses { 
	public int getTotal() { 
		// 기본값으로 일일 기본 식비를 반환한다. 
	} 
}
~~~

<br>

## null을 반환하지 마라
null을 반환하면 null을 확인하는 코드를 매번 작성해야 한다. (언제 NullPointerException이 발생할 지 예상할 수 없다.)    

<br>

## null을 전달하지 마라
> 메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다. 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.

<br>

## 결론
> 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.

