---
title: 17. 냄새와 휴리스틱
date: "2022. 2. 12"
summary: Clean Code(클린 코드) 17장을 읽고 학습한 내용 정리
---

> Clean Code(클린 코드) 책을 읽으면서 정리한 내용입니다.

<br>


### 주석
#### 주석으로 많은 내용을 작성하려고 하지 말자.
> 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다. (p. 368)

코드의 변경 이력과 같은 Git으로 관리되어야 할 정보는 주석으로 적절하지 못하다.

#### 쓸모 없는 주석은 제거한다.
쓸모 없어진 주석은 코드와 따로 놀면서 코드를 그릇된 방향으로 이끌기 때문에 바로바로 삭제해야 한다.

#### 중복된 주석을 작성하지 않는다.
코드만으로 충분한 내용을 주석으로 작성할 필요는 없다.

~~~java
// 나쁜 예
i++; // i값 증가
~~~

#### 성의 있게 주석을 작성하라
작성할 가치가 있는 주석이라면 코드를 작성하는 것처럼 간결하고 명료하게 작성한다.

#### 코드 변경 이력은 Git이 기억한다.
> 주석으로 처리된 코드를 발견하면 즉각 지워버려라!  (p. 369)

<br>

### 환경
#### 한 단계로 빌드해야 한다.
> 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다. (p. 370)

#### 한 단계로 테스트해야 한다.
> 모든 단위 테스트는 한 명령으로 돌려야 한다. (p. 370)

<br>
### 함수
#### 인수 개수는 작을수록 좋다.
함수의 인수는 0개 > 1개 > 2개 > 3개 ...     
적으면 적을수록 좋다.

#### 출력 인수를 사용하지 말자.
일반적으로 함수를 호출할 때 인수를 입력으로 간주한다. 

#### 플래그 인수를 사용하지 말자.
boolean 타입의 플래그 인수는 함수가 여러 기능을 수행한다는 증거이다.

<br>

### 일반
#### 한 소스 파일에 한 가지 언어만 사용하자.
> 현실 적으로는 여러 언어가 불가피하다. 하지만 각별한 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 애써야 한다. (p. 371)

#### 당연한 동작을 구현하자.
일반적으로 당연하게 여길만한 동작과 기능을 구현해야 한다.    

#### 경계를 올바로 처리하자.
> 부지런함을 대신할 지름길은 없다. 모든 경계 조건, 모든 구석진 곳, 모든 기벽, 모든 예외는 우아하고 직관적인 알고리즘을 자초시킬 암초다. 스스로의 직관에 의존하지 마라. 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라. (p. 372)

#### 안전 절차를 무시하지 말자.
> 실패하는 테스트 케이스를 일단 재껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다. (p. 372)

#### 중복 제거!
프로그래밍의 핵심 규칙 중 하나이다. 정말정말 중요!     
코드에서 중복을 발견하면 추상화할 기회로 간주하고, 중복 코드를 하위 메소드나 다른 클래스로 분리한다.     

> 사실 최근 15년 동안 나온 디자인 패턴은 대다수가 중복을 제거하는 잘 알려진 방법에 불과하다. (p. 373)

#### 올바른 추상화 수준
추상화를 할 때 저차원 개념에서 고차원 일반 개념(공통되는 부분)을 분리한다.     
이런 추상화는 고차원 일반 개념은 추상 클래스나 인터페이스로 저차원 개념은 파생 클래스나 구현 클래스로 표현된다.     

이 과정에서 고차원 개념과 저차원 개념이 섞이면 안된다.     

~~~java
public interface Stack {
	Object pop() throws EmptyException;
	void push(Object o) throws FullException;
	double percentFull(); // 저차원 개념에 해당
	class EmptyException extends Exception();
	class FullException extends Exception();
}
~~~

위 Stack 인터페이스에 percentFull은 잘못 추상화 되었다.    
Stack은 어떻게 구현되는가에 따라서 '꽉 찬 정도'라는 개념이 다르다. 심지어 어떤 Stack은 꽉 찬다는 개념이 없을수도 있다.     

**올바른 추상화**

~~~java
public interface Stack {
	...
}

// 1안. 파생 인터페이스
public interface LimitedStack extends Stack {
	double percentFull();
}

// 2안. 구현 클래스 
public class LimitedStack implements Stack {
	double percentFull() {
		...
	}
} 
~~~

#### 기초 클래스는 파생 클래스를 몰라야 한다.
> 개념을 기초 클래스와 파생 클래스로 나누는 가장 흔한 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위해서다.  (p. 375)
> 

#### 작은 인터페이스
> 잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. 그래서 결합도가 낮다. (p. 375)

#### 죽은 코드 제거
- 불가능한 조건을 확인하는 if문
- throw문이 없거나 의미가 없는 예외처리
- 아무 곳에서도 호출되지 않는 유틸리티 함수

> 죽은 코드를 발견하면 올바른 행동을 취하기 바란다. 적절한 장례식을 치뤄주라. 시스템에서 제거하라. (p. 376)

#### 수직 분리
지역 변수는 가능한 처음 사용하기 직전에 선언하고, 수직으로 가까운 곳에 위치시킨다.    
비공개 함수는 호출하는 위치와 최대한 가깝게 유지한다.     

### 일관성을 유지
> 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다. (p. 376)

#### 잡동사니 제거
- 빈 기본 생성자
- 아무도 사용하지 않는 변수
- 아무도 호출하지 않는 함수
- 필요없는 주석

#### 인위적인 결합 제거
서로 문관한 개념은 결합하지 않는다. 함수, 상수, 변수의 선언 위치는 시간을 들여 올바른 위치를 고민한다.

#### 기능 욕심을 부리지 말자
어쩔 수 없는 경우가 아니라면 다른 객체의 참조자와 변경자를 사용해서 그 객체의 클래스의 범위를 욕심내지 않아야 한다.

#### G15. 선택자 인수
##### 선택자 인수를 피해라
선택자 인수는 목적을 기억하기 어렵고, 충분히 분리될 수 있는 함수를 하나로 조합시킨다. 

#### G16. 모호한 의도
##### 코드의 의도를 최대한 분명하게 밝히자.
> 독자에게 의도를 분명히 표현하도록 시간을 투자할 가치가 있다.  (p. 380)

#### G17. 잘못 지운 책임
##### 코드의 위치를 정할 때 책임에 집중하자.
코드를 자연스럽게 기대할 위치에 배치하려면 함수의 이름을 살피거나 함수가 진 책임과 결합이 된 기능인지 확인한다.

#### G18. 부적절한 static 함수
static 메서드는 메서드 내에서 사용하는 정보가 인수가 전부이다. 메서드를 소유하는 객체로부터 정보를 가져와서는 안된다.

#### G19. 서술적 변수
> 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값을 서술적인 변수 이름을 사용하는 방법이다.  (p. 382)

#### G20. 이름과 기능이 일치하는 함수
이름만으로 기능을 예상할 수 있고, 예상하는 대로 동작하도록 이름을 지어야 한다.

#### G21. 알고리즘을 이해하라
##### 알고리즘을 충분히 이해한 상태에서 코드를 구현하자.
테스트 케이스가 모두 통과한다는 사실만으로는 부족하다. 함수가 작성된 알고리즘을 정확하게 이해하고, 그 방식이 올바르다는 사실을 알고 있는게 먼저다. 테스트는 그 올바르다고 생각되는 알고리즘이 정상적으로 돌아가고 있다는 확신만 준다.

#### G22. 논리적 의존성은 물리적으로 드러내라
##### 상대 모듈에 대해 뭔가를 가정하면 안된다.
의존하는 모든 논리적인 정보를 명시적으로 요청하는게 좋다.

#### G23. if/else 혹은 switch/case 문보다 다형성을 사용하라
switch문을 선택하기 전에는 다형성을 먼저 고려해야 한다.

#### G24. 표준 표기법을 따르라
##### 팀은 업계 표준에 기반한 구현 표준을 따라야 한다. (업계 표준 > 팀 표준)
> 표준을 설명하는 문서는 코드 자체로 충분해야 하며 별도 문서를 만들 필요는 없어야 한다.  (p. 386)

#### G25. 매직 숫자는 명명된 상수로 교체하라
##### 코드에서 숫자를 사용하지 마라
너무나도 잘 알려진 고유한 숫자이거나 숫자를 보면 바로 의도를 유추할 수 있다면 상관없다.     
그렇지 않다면 숫자는 명명된 상수 뒤로 숨겨야 한다.    

'매직 숫자'라고 해서 꼭 숫자만 의미하지는 않는다. 의미가 분명하지 않은 문자열도 해당한다.

#### G26. 정확하라
##### 코드에서 무언가를 결정할 때는 정확히 결정해라
코드의 모호성과 부정확은 게으름의 결과이다.

#### G27. 관례보다 구조를 사용하라
##### 설계 결정을 강제할 때는 규칙보다 관례를 사용한다.

#### G28. 조건을 캡슐화하라
조건의 의도를 분명하게 밝히는 함수로 표현하라.

~~~java
if (shouldBeDeleted(timer)) // O

if (timer.hasExpired() && !timer.isRecurrent()) // X
~~~

#### G29. 부정 조건은 피하라
##### 긍정 조건을 사용하라
> 부정 조건은 긍정 조건보다 이해하기 어렵다. 가능하면 긍정 조건으로 표현한다.  (p. 389)

#### G30. 함수는 한 가지만 해야 한다.

#### G31. 숨겨진 시간적인 결합
함수의 실행 순서가 중요한 경우 적절한 결합을 통해서 호출 순서를 강제하는 게 좋다.

~~~java
public void dive(String reason) {
	Gradient gradient = saturateGradient();
	List<Spline> splines = reticulateSplines(gradient);
	diveForMoog(splines, reason);
}
~~~

#### G32. 일관성을 유지하라
> 코드 구조를 잡을 때는 이유를 고민하라. 그리고 그 이유를 코드 구조로 명백히 표현하라.  (p. 391)

> 시스템 전반에 걸쳐 구조가 일관성이 있다면 남들도 일관성을 따르고 보존한다.  (p. 391)

유명한 Github 오픈소스를 보면 여러 사람이 같이 작업을 진행하지만 코드의 일관성있게 작성되어있다.

#### G33. 경계 조건을 캡슐화하라
경계 조건은 한 곳에서 별도로 처리한다.

#### G34. 함수는 추상화 수준을 한 단계만 내려가야 한다.
> 함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.  (p. 392)

#### G35. 설정 정보는 최상위 단계에 둬라
기본값 상수나 설정 관련 상수는 추상화 최상위 단계에 둬야 한다.

#### G36. 추이적 탐색을 피하라
##### A가 B를 사용하고, B가 C를 사용한다고 하더라도 A가 C를 알아야 할 필요는 없다.
a.getB().getC().doSomething() 과 같은 코드는 바람직하지 않다.

<br>

### 자바
#### J1. 긴 import 목록을 피하고 와일드카드를 사용하라
> 패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라.  (p. 396)

~~~java
import package.*;
~~~

#### J2. 상수는 상속하지 않는다.
상수를 인터페이스에 넣은 다음 그 인터페이스를 상속받아서 상수를 사용하면 안된다.

#### J3. 상수 대 Enum
상수보다 Enum을 마음껏 활용하자.     
enum은 **이름**이 부여된 열거체에 속한다.    

<br>

### 이름
#### N1. 서술적인 이름을 사용하라
##### 서술적인 이름을 신중하게 골라서 작성해라
> 소프트웨어 가독성의 90%는 이름이 결정한다.  (p. 399)

#### N2. 적절한 추상화 수준에서 이름을 선택하라
구현을 드러내는 이름은 피하라. 함수가 위치하는 추상화 수준만 반영하는 이름을 선택하자.

#### N3. 가능하다면 표준 명명법을 사용하라
당연한 이유로 독자가 코드를 이해하기 매우 쉬워진다.

#### N4. 명확한 이름
##### 함수나 변수의 목적을 명확히 밝히는 이름을 선택하라

#### N5. 긴 범위는 긴 이름을 사용하라
> 이름 길이는 범위 길이에 비례해야 한다. 범위가 작으면 아주 짧은 이름을 사용해도 괜찮다.  (p. 403)

#### ~~N6. 인코딩을 피하라~~

#### N7. 이름으로 부수 효과를 설명하라

<br>

### 테스트
#### T1. 불충분한 테스트
~~"이 정보면 충분하지 않을까?"~~     
테스트 케이스는 가능한 많이 작성해야 한다.

#### T2. 커버리지 도구를 사용하라!
> 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다. 커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다.  (p. 404)

#### T3. 사소한 테스트를 건너뛰지 마라
사소한 테스트도 모두 작성해야 한다.

#### T4. 무시한 테스트는 모호함을 뜻한다.
> 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트에 @Ignore를 붙여서 표현한다.   (p. 405)

#### T5. 경계 조건을 테스트하라
##### 경계 조건은 각별히 신경 써서 테스트한다.

#### T6. 버그 주변은 철저히 테스트하라
버그는 서로 모이는 경향이 있다. 버그를 발견하면 해당 부분을 위주로 철저히 테스트하는게 좋다.

#### T7. 실패 패턴을 살펴라
실패하는 테스트들의 패턴을 살피다 보면 문제를 해결할 방법을 찾을 가능성이 높아진다. 

#### T8. 테스트 커버리지 패턴을 살펴라
실행하지 않는 코드를 살피면 실패 원인이 드러나는 경우도 있다. 

#### T9. 테스트는 빨라야 한다.
