---
title: 06. 객체와 자료 구조
date: "2021. 12. 30"
summary: Clean Code(클린 코드) 6장을 읽고 학습한 내용 정리
---

객체의 변수를 private으로 정의하는 이유는 객체를 사용하는 쪽에서 특정 변수나 구현에 의존하지 않게 하기 위해서이다. 그러면 private 변수를 public getter, setter를 통해 외부에 노출하는 이유는 무엇일까??    

<br>

## 자료 추상화
단순히 변수를 private으로 감춘다고 구현이 감춰지지 않는다. 구현을 감추려면 추상화가 필요하다.   
진정한 의미의 객체는 구현을 모른 채 자료의 핵심을 조작할 수 있도록 추상 인터페이스를 제공한다.   
<br>
## 자료/객체 비대칭
> <u>객체는</u> 추상화 뒤로 <u>자료를 숨긴 채</u> <u>자료를 다루는 함수만 공개</u>한다. 
> <u>자료 구조는</u> <u>자료를 그대로 공개</u>하며 별다른 <u>함수는 제공하지 않는다.</u>

> <u>객체지향 코드는</u> 새로운 <u>자료나 클래스를 추가하기 쉽고</u>, 새로운 <u>함수를 추가하는 건 어렵다.</u>
> <u>절차지향 코드는</u> <u>자료를 추가하기 어렵고</u>, <u>새로운 함수를 추가하는 건 쉽다.</u>

객체지향은 객체의 내부 자료 구조와 구현을 객체지향의 특성인 캡슐화로 감춰 사용하는 쪽에서 이에 종속되지 않도록 하는 대신 함수나 클래스를 변경하거나 추가할 때 좀 더 신경 쓸 것이 많고, 불편함을 감수해야 한다.
<br>
## 디미터 법칙
> 디미터 법칙은 잘 알려진 휴리스틱으로, **모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다**는 법칙이다.
> 앞 절에서 봤듯이, 객체는 자료를 숨기고 함수를 공개한다.

객체가 다른 객체를 지나치게 많이 알게 되면 결합도가 높아지기 때문에 좋지 못한 코드가 된다. 그래서 객체를 만들 때 내부 자료구조는 숨기고(private), 대신 함수를 공개하도록 하는 법칙이 디미터 법칙이다.    
(캡슐화를 통해서 객체의 응집도는 높이고, 객체끼리의 결합도는 낮춘다.)
<br>
### 결론 
외부로 공개되는 부분(public)은 당연하게 수정하기 힘들다. 사용하는 쪽도 모두 수정해야 하기 때문이다.    


**객체는 동작을 공개하고 자료를 숨기고, 자료 구조는 반대로 동작이 없이 자료를 공개한다.**        
서로 반대의 특징을 가진다. 객체는 동작, 자료 구조는 자료가 공개되기 때문에 수정하기 힘들다.     

- 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 적합
- 새로운 동작을 추가하는 유연성이 필요하다면 자료 구조와 절차적인 코드가 적합

이 두 가지가 섞이는 경우 서로의 단점을 모두 안고 가는 것이기 때문에 좋은 코드가 아니다. 